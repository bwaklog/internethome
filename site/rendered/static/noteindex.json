{"notes/kv colab/IO syscalls are blocking operations.html":{"CompleteURL":"notes/kv colab/IO syscalls are blocking operations.html","Date":1713312000,"Frontmatter":{"Title":"IO syscalls are blocking operations","Date":"2024-04-17","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eIf a read request is fired, it wouldn't do anything until the data from the other side is sent over. We are invoking read, without knowing if the other client has any data to send over. The problem with such a system is that, there could be other clients with data that is ready to be sent over, need to wait for the currently connected client to finish send over some kind of data.\u003c/p\u003e\n\u003cp\u003eWith a multi thread approach, other processes can be scheduled while \u0026quot;waiting\u0026quot; for the data to get sent over. This makes use use stuff like semaphores for ensuring \u0026quot;correctness\u0026quot; of data\u003c/p\u003e\n","MarkdownBody":"If a read request is fired, it wouldn't do anything until the data from the other side is sent over. We are invoking read, without knowing if the other client has any data to send over. The problem wi","LinkedNoteURLs":[],"LiveReload":false},"notes/kv colab/In memory storage of the database.html":{"CompleteURL":"notes/kv colab/In memory storage of the database.html","Date":1713225600,"Frontmatter":{"Title":"In memory storage of the database","Date":"2024-04-16","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"","MarkdownBody":"","LinkedNoteURLs":[],"LiveReload":false},"notes/kv colab/Json like abstraction in Automerge.html":{"CompleteURL":"notes/kv colab/Json like abstraction in Automerge.html","Date":1713052800,"Frontmatter":{"Title":"Json like abstraction in Automerge","Date":"2024-04-14","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eAn example of some kind of representation of data as a todo list\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{ \n    \u0026quot;to-do\u0026quot;: [\n        {\u0026quot;title\u0026quot;: \u0026quot;buy-milk\u0026quot;, \u0026quot;done\u0026quot;: false},\n        {\u0026quot;title\u0026quot;: \u0026quot;take-out-trash\u0026quot;, \u0026quot;done\u0026quot;: true}\n    ]\n    \u0026quot;settings\u0026quot;: {\n        \u0026quot;alert-sound\u0026quot;: \u0026quot;ring\u0026quot;,\n    },\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can have editing operations, such as insertion of new tasks, adding a new data structure, updating values...\u003c/p\u003e\n\u003cp\u003eAutomerge uses \u003ca id=\"zettel-reference\" href=\"/notes/kv colab/immutable state objects.html\"\u003eimmutable state objects\u003c/a\u003e, where the current state of data cannot be modified. Automerge capture the canges and stores the operations made in a \u003cstrong\u003elog of operations\u003c/strong\u003e, somewhat like this\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e{action: \u0026quot;make-map\u0026quot;, obj: id1}\n{action: \u0026quot;set\u0026quot;, obj: id1, key: \u0026quot;title\u0026quot;, value: \u0026quot;Buy Milk\u0026quot;}\n...\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHaving a log enables us to \u003ca id=\"zettel-reference\" href=\"/notes/kv colab/travel back commits.html\"\u003etravel back commits\u003c/a\u003e . Using this we can probably roll back into commits, and open up snapshots of them.\u003c/p\u003e\n","MarkdownBody":"An example of some kind of representation of data as a todo list\n\n```json\n{ \n    \"to-do\": [\n        {\"title\": \"buy-milk\", \"done\": false},\n        {\"title\": \"take-out-trash\", \"done\": true}\n    ]\n    \"s","LinkedNoteURLs":["notes/kv colab/immutable state objects.html","notes/kv colab/travel back commits.html"],"LiveReload":false},"notes/kv colab/K-V Store implementation.html":{"CompleteURL":"notes/kv colab/K-V Store implementation.html","Date":1713225600,"Frontmatter":{"Title":"K-V Store implementation","Date":"2024-04-16","Draft":false,"JSFiles":null,"Type":"note","Description":"The following collection of all notes i've made while trying to figure out CRDT, Automerge, how Redis works, what makes it so special and more","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003ch2 id=\"understanding-redis\"\u003eUnderstanding Redis\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRedis utilises the cache on board the system rather than just the secondary memory.\u003c/li\u003e\n\u003cli\u003eData is modified on the primary memory\u003c/li\u003e\n\u003cli\u003eData is stored on the disk for reconstruction - snapshots and backups\u003c/li\u003e\n\u003cli\u003eMore on the data structure : keys are associated to almost any type of \u003cem\u003edata structure\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"specifications\"\u003eSpecifications\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca id=\"zettel-reference\" href=\"/notes/kv colab/Redis operations are atomic in nature.html\"\u003eRedis operations are atomic in nature\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca id=\"zettel-reference\" href=\"/notes/kv colab/In memory storage of the database.html\"\u003eIn memory storage of the database\u003c/a\u003e, allowing for it to be stored in cache\u003c/li\u003e\n\u003cli\u003eTransactions: while executing a transaction, nothing else is performed\u003c/li\u003e\n\u003cli\u003ePub/Sub: a publisher and consumer can listen to the same redis. Publishing to a \u0026quot;topic\u0026quot; in a redis, all the consumers listening to that topic would recieve that same topic.\u003c/li\u003e\n\u003cli\u003eTTL : Enables key expiration. Example condition, user log out after a certain duration, rather than having the key persist throughout.\u003c/li\u003e\n\u003cli\u003eLRU eviction : When the cache is full, keys are evicted.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor a concurrent programming mode, there can be two approaches. One could be a \u003ca id=\"zettel-reference\" href=\"/notes/kv colab/Multi threaded process with each request in a new thread.html\"\u003eMulti threaded process with each request in a new thread\u003c/a\u003e. Another is a \u003ca id=\"zettel-reference\" href=\"/notes/kv colab/Single threaded process with IO Multiplexing.html\"\u003eSingle threaded process with IO Multiplexing\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=h30k7YixrMo\"\u003eWhat makes Redis Special\u003c/a\u003e by Arpit Bhayani\u003c/li\u003e\n\u003c/ul\u003e\n","MarkdownBody":"## Understanding Redis\n\n- Redis utilises the cache on board the system rather than just the secondary memory. \n- Data is modified on the primary memory\n- Data is stored on the disk for reconstruction ","LinkedNoteURLs":["notes/kv colab/Redis operations are atomic in nature.html","notes/kv colab/In memory storage of the database.html","notes/kv colab/Multi threaded process with each request in a new thread.html","notes/kv colab/Single threaded process with IO Multiplexing.html"],"LiveReload":false},"notes/kv colab/KV Collab and Merging.html":{"CompleteURL":"notes/kv colab/KV Collab and Merging.html","Date":1713052800,"Frontmatter":{"Title":"KV Collab and Merging","Date":"2024-04-14","Draft":false,"JSFiles":null,"Type":"note","Description":"The following collection of all notes i've made while trying to figure out CRDT, Automerge, how Redis works, what makes it so special and more","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":true},"Body":"\u003ch1 id=\"referrals\"\u003eReferrals\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://automerge.org/\"\u003eAutomerge\u003c/a\u003e using CRDT implementation\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"\"\u003eGoogle Docs\u003c/a\u003e using the same implementation\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://webrtc.org/\"\u003eWebRTC\u003c/a\u003e enabling \u003cstrong\u003ereal time\u003c/strong\u003e communication : server less approach. More of a P2P approach\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/automerge/mpl\"\u003eMPL\u003c/a\u003e P2P Document synchronisation system for automerge\u003c/li\u003e\n\u003cli\u003eThink about \u003ca href=\"\"\u003eWeb Sockets\u003c/a\u003e for client/server communications\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"notes\"\u003eNotes\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca id=\"zettel-reference\" href=\"/notes/kv colab/Json like abstraction in Automerge.html\"\u003eJson like abstraction in Automerge\u003c/a\u003e for application data.\u003c/li\u003e\n\u003cli\u003e\u003ca id=\"zettel-reference\" href=\"/notes/kv colab/K-V Store implementation.html\"\u003eK-V Store implementation\u003c/a\u003e for the database side of the application\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"resources\"\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://raft.github.io/raft.pdf\"\u003eRaft Paper\u003c/a\u003e by \u003cem\u003eDiego Ongaro\u003c/em\u003e and \u003cem\u003eJohn Ousterhout\u003c/em\u003e from Stanford University\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://martin.kleppmann.com/2021/06/04/craft-conf.html\"\u003eCreation of a Local-First Collaboration software with Automerge\u003c/a\u003e by Martin Kleppmann\u003c/li\u003e\n\u003cli\u003eOriginal Paper on \u003ca href=\"https://lamport.azurewebsites.net/pubs/time-clocks.pdf\"\u003eLamport Time Clocks\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","MarkdownBody":"# Referrals\n\n- [Automerge](https://automerge.org/) using CRDT implementation\n- [Google Docs]() using the same implementation\n- [WebRTC](https://webrtc.org/) enabling **real time** communication : serv","LinkedNoteURLs":["notes/kv colab/Json like abstraction in Automerge.html","notes/kv colab/K-V Store implementation.html"],"LiveReload":false},"notes/kv colab/Multi threaded process with each request in a new thread.html":{"CompleteURL":"notes/kv colab/Multi threaded process with each request in a new thread.html","Date":1713225600,"Frontmatter":{"Title":"Multi threaded process with each request in a new thread","Date":"2024-04-16","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eEach request to the TCP is handled by a separate thread. With this mutexes or semaphores can be put in place that ensures \u003cem\u003edata correctness\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eR1 -\u0026gt; INCR K -\u0026gt; Thread 1\nR2 -\u0026gt; INCR K -\u0026gt; Thread 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf there aren't any guard rails in place for this process, the output in the kv could be unpredictable where. To ensure data correctness after execution of both operations, we need to add in a locking mechanism.\u003c/p\u003e\n\u003cp\u003eWithout locks, there is a good chance for unpredictable output. The final data wouldn't represent the true correct value\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e      ┌─────────┐ \nT1 -\u0026gt; │  K + 1  │ ===\u0026gt; 10 ++ ~\u0026gt; 11\n      └─────────┘\n\t  \n      ┌─────────┐ \nT2 -\u0026gt; │  K + 1  │ ===\u0026gt; 10 ++ ~\u0026gt; 11\n      └─────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese locks to threads ensure concurrency safety where at max only \u003cem\u003eone thread\u003c/em\u003e can acquire a lock. This can be achieved with the help of using \u003cem\u003emutexes\u003c/em\u003e or \u003cem\u003esemaphores\u003c/em\u003e.\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"/static/images/notes/aqu-rel_lock_multi_thread.png\" alt=\"Diagram representing how the locking mechanism would take place\"\u003e\n\u003c/figure\u003e\n","MarkdownBody":"Each request to the TCP is handled by a separate thread. With this mutexes or semaphores can be put in place that ensures *data correctness*. \n\n```\nR1 -\u003e INCR K -\u003e Thread 1\nR2 -\u003e INCR K -\u003e Thread 2\n``","LinkedNoteURLs":[],"LiveReload":false},"notes/kv colab/Redis exploits in memory operation speeds.html":{"CompleteURL":"notes/kv colab/Redis exploits in memory operation speeds.html","Date":1713312000,"Frontmatter":{"Title":"Redis exploits in memory operation speeds","Date":"2024-04-17","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eThe idea is quite simple.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNetwork I/O operations are \u003cstrong\u003eSLOW\u003c/strong\u003e \u0026amp; Memory operations are simply \u003cstrong\u003eFAST\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHaving a TCP accepting multiple connections and execution done through a single thread. Redis relies on the speed of \u003cem\u003ein-memory\u003c/em\u003e operations. Single threaded processes drops the need of using a locking mechanism.\u003c/p\u003e\n\u003cp\u003eIO Multiplexing deals with handling multiple TCP connections \u003cem\u003econcurrently\u003c/em\u003e. It handles all executions in a sequential fashion \u0026amp; Redis is capable of supporting a \u003cem\u003elarge\u003c/em\u003e number of these TCP connections.\u003c/p\u003e\n","MarkdownBody":"The idea is quite simple.\n\n\u003e Network I/O operations are **SLOW** \u0026 Memory operations are simply **FAST**\n\nHaving a TCP accepting multiple connections and execution done through a single thread. Redis ","LinkedNoteURLs":[],"LiveReload":false},"notes/kv colab/Redis operations are atomic in nature.html":{"CompleteURL":"notes/kv colab/Redis operations are atomic in nature.html","Date":1713139200,"Frontmatter":{"Title":"Redis operations are atomic in nature","Date":"2024-04-15","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eCommand executions on redis (in case multiple are stacked due to multiple client connections), in only starts executing the other commands when the previous one has been completed\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThere is no context switching and execution of \u0026quot;other\u0026quot; commands\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis assures a safe concurrency nature of the db. In general operations like increment are not concurrent safe. Having n connections incrementing a value of a filed will need to keep each increment stored in the final snapshot of the db. Hence, having an atomic model of the db ensures, each of the valid operations results reflects on the final output.\u003c/p\u003e\n","MarkdownBody":"Command executions on redis (in case multiple are stacked due to multiple client connections), in only starts executing the other commands when the previous one has been completed\n\n\u003e There is no conte","LinkedNoteURLs":[],"LiveReload":false},"notes/kv colab/Single threaded process with IO Multiplexing.html":{"CompleteURL":"notes/kv colab/Single threaded process with IO Multiplexing.html","Date":1713225600,"Frontmatter":{"Title":"Single threaded process with IO Multiplexing","Date":"2024-04-16","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eRedis has taken up more of a single threaded approach. Instead of a multi thread model, where each thread handles a separate request, Redis has taken an option to exploit the speed of in memory operations, and having a different approach on fetching data.\u003c/p\u003e\n\u003cp\u003eRedis follows something called \u003cem\u003eI/O  Multiplexing\u003c/em\u003e which produces an \u0026quot;apparent\u0026quot; concurrency unlike true concurrency that is achieved by multithreading the process.\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"/static/images/notes/network-syscall-blocks.png\" alt=\"Diagram showing blocking calls over network\"\u003e\n\u003c/figure\u003e\n\u003cp\u003e\u003ca id=\"zettel-reference\" href=\"/notes/kv colab/IO syscalls are blocking operations.html\"\u003eIO syscalls are blocking operations\u003c/a\u003e, they would make the process more inefficient rather than doing more productive work as shown above. This could be solved with a multi threaded approach, by using locking mechanisms (as seen in \u003ca id=\"zettel-reference\" href=\"/notes/kv colab/Multi threaded process with each request in a new thread.html\"\u003eMulti threaded process with each request in a new thread\u003c/a\u003e), but this wastes valuable time when we already have a connection ready to send data over\u003c/p\u003e\n\u003ch2 id=\"solution-to-the-problem\"\u003eSolution to the problem\u003c/h2\u003e\n\u003cp\u003eThere can be some kind of notification mechanism for I/O movements. We can notify the server for example through a TCP connection, that it has data ready to be sent over, only then the server fires a \u003ccode\u003eread\u003c/code\u003e request to that particular client.\u003c/p\u003e\n\u003cp\u003eWe are not dealing with network sys-calls like read, rather just I/O monitoring calls where we are watching the TCP connections. This achieves a single threaded process. This is the niche where \u003ca id=\"zettel-reference\" href=\"/notes/kv colab/Redis exploits in memory operation speeds.html\"\u003eRedis exploits in memory operation speeds\u003c/a\u003e\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"/static/images/notes/notsoaccurate-repr-io-mux.png\" alt=\"A not so accurate diagram of IO multiplexing\"\u003e\n\u003c/figure\u003e\n","MarkdownBody":"Redis has taken up more of a single threaded approach. Instead of a multi thread model, where each thread handles a separate request, Redis has taken an option to exploit the speed of in memory operat","LinkedNoteURLs":["notes/kv colab/IO syscalls are blocking operations.html","notes/kv colab/Multi threaded process with each request in a new thread.html","notes/kv colab/Redis exploits in memory operation speeds.html"],"LiveReload":false},"notes/kv colab/immutable state objects.html":{"CompleteURL":"notes/kv colab/immutable state objects.html","Date":1713139200,"Frontmatter":{"Title":"immutable state objects","Date":"2024-04-15","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eThe state of data is \u003cem\u003enever\u003c/em\u003e modified in place. To change it, we pass the current state of it through an \u003ccode\u003eAutomerge.change\u003c/code\u003e function that returns a new object where that change is reflected along side a possible commit message that is with the change\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// pesudo code\nstate = Automerge.change(state, \u0026quot;Some kind of message\u0026quot;) {\n\t(doc) =\u0026gt; {\n\t\t\tdoc.todo.push({\n\t\t\t\t\u0026quot;title\u0026quot;: \u0026quot;Dry Laundry\u0026quot;,\n\t\t\t\t\u0026quot;done\u0026quot;: false,\n\t\t\t})\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe \u003ccode\u003edoc\u003c/code\u003e callback here is mutable only within the callback.\u003c/p\u003e\n","MarkdownBody":"The state of data is *never* modified in place. To change it, we pass the current state of it through an `Automerge.change` function that returns a new object where that change is reflected along side","LinkedNoteURLs":[],"LiveReload":false},"notes/kv colab/travel back commits.html":{"CompleteURL":"notes/kv colab/travel back commits.html","Date":1713139200,"Frontmatter":{"Title":"travel back commits","Date":"2024-04-15","Draft":false,"JSFiles":null,"Type":"note","Description":"","PreviewImage":"","Tags":null,"TOC":false,"Authors":null,"Head":false},"Body":"\u003cp\u003eTravelling back would seem necessary only in case of having a database. This is kind of the current requirement of the idea, so it would seem practical. Here is a basic idea from \u003cem\u003eAutomerge\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eAutomerge.getHistory(state)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e[\n\t{change: {message: \u0026quot;Add todo item...\u0026quot;},\n\tsnapshot: {todos: [{title: \u0026quot;Buy milk\u0026quot;, ...}, ... ]}},\n\t\n\t{change: {message: \u0026quot;Marking item as done ... \u0026quot;},\n\tsnapshot: {todos: [{title: \u0026quot;Buy milk\u0026quot;, ...}, ... ]}}\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKeeping the idea of a k-v store in mind, this seems pretty reasonable to implement. There could be 2 different types\u003c/p\u003e\n","MarkdownBody":"Travelling back would seem necessary only in case of having a database. This is kind of the current requirement of the idea, so it would seem practical. Here is a basic idea from *Automerge*\n\n```js\nAu","LinkedNoteURLs":[],"LiveReload":false}}